---
title: Fee-Bump Transactions
order:
---
A fee-bump transaction enables any account to pay the fee for an existing [transaction](./transactions.mdx) without the need to re-sign the existing transaction or manage sequence numbers.  They're useful if you need to increase the fee on an pre-signed transaction, or if you want to build a service that covers user fees.  Unlike a regular transaction, which contains 1-100 [operations](./operations.mdx), a fee bump transaction contains a single [transaction enevelope](./transactions.mdx/#transaction-envelopes).     

## Fee-Bump Transaction Attributes

Each fee-bump transaction encloses a single transaction envelope, which itself encloses a single inner transaction.  Before creating a fee bump transaction, in other words, you must first have a [transaction](./transactions.mdx) wrapped with requisite signatures in a [transaction envelope](./transactions.mdx/#transaction-envelopes). 

In addition to a transaction envelope, each fee-bump transaction has the following attributes:

### Fee Account
The account that provides the fee for the fee-bump transaction.  It incurs the fee instead of the source account specified in the inner transaction.  The sequence number for the fee-bump transaction, however, is still taken from the source account specified in the inner transaction.

### Fee
The maximum fee you are willing to pay for the fee-bump transaction.  

A fee-bump transaction has an effective number of operations equal to one plus the number of operations in the inner transaction. Therefore, the minimum fee for a fee-bump transaction is one base fee *more* than the minimum fee for
the inner transaction, and the fee rate is normalized by one plus the number of operations in the inner transaction.  For more info, see [Fees](./fees.mdx).

#### Replace-by-Fee
You can use a fee bump transaction to increase the fee on a transaction originating from your own account.  However, there is a condition: if you submit two distinct transactions with the same source account and sequence number, and the second transaction is a fee-bump transaction, the second transaction will be included in the transaction queue in place of the first transaction if and only if the fee bid of the second transaction is *at least 10-times the fee bid of the first transaction*.  Though that limit may seem somewhat arbitrary, it was a deliberate design decision to limit DOS attacks without introducing too much complexity to the protocol.

## Fee-Bump Transaction Envelopes
Once a fee-bump transaction is ready to be signed, it's wrapped in a transaction envelope, which contains the fee-bump transaction as well as the signature of the Fee Account specified in the fee-bump transaction. 

Ultimately, transaction envelopes are passed around the network and are included in transaction sets, as opposed to raw transaction objects.   

## Validity of a Fee-Bump Transaction
Like regular transactions, fee-bump transactions goe through a series of checks in their lifecycle to determine validity.

The following conditions determine whether a fee bump transaction is valid:

- **Fee Account** — The fee account for the fee bump must exist on the ledger.

`E.feeBump().tx.feeSource` has sufficient available native balance (see
  CAP-0003) to pay `E.feeBump().tx.fee` in addition to fees that will be paid by
  this account for other transactions, otherwise return `txINSUFFICIENT_BALANCE`  


- **Fee** — The fee must be greater than or equal to the [network minimum fee](./fees.mdx) for the number of operations in the inner transaction, +1 for the fee bump.  It must also be greater than or equal to the fee specfied in the inner transaction. - 


Submitted fee-bump transaction envelopes go through a similar validation process. But unlike transaction envelopes, fee-bump transaction envelopes support the replace-by-fee mechanism. When replace-by-fee occurs, a transaction envelope or fee-bump transaction envelope in the transaction queue is replaced by a fee-bump transaction envelope with the same sequence number and source account, but a fee that is at least 10x higher. 

Imagine, for example, that you submit a transaction envelope to a Stellar-Core node which is accepted because its fee was above the minimum fee. But your transaction envelope does not get included in the ledger due to surge pricing, and you want to accelerate the process. Without the replace-by-fee mechanism, you would not be able to successfully submit a fee-bump transaction envelope with a higher fee because the sequence number would not be sequential. With it, however, you are actually able to to bump the fee.


- **List of Signatures** — In addition to meeting the signature requirements of each operation in the transaction, the following requirements must be met for the transaction:
  - The appropriate network passphrase was part of the transaction hash that was signed by each of the signers. See [Network Passphrases](./network-passphrase.mdx) for more.
  - The combined weight of all signatures for the source account _of the fee bump transaction_ meets the low threshold for the source account. This is necessary in order for fees to be taken and the sequence number to be incremented later in the transaction lifecycle.


#### Application and Results
Even if the outer transaction of a fee-bump is invalid during application, we
will still apply the inner transaction. Specifically, the behavior is:

- Remove used one-time signers for the outer transaction
- Apply the inner transaction (as if there were no outer transaction)

If the inner transaction succeeds, then the result is `txFEE_BUMP_INNER_SUCCESS`
and the `innerResultPair` is what would have been produced by the inner
transaction in the absence of the outer transaction. Analogously, if the inner
transaction fails, then the result is `txFEE_BUMP_INNER_FAILED` and the
`innerResultPair` is what would have been produced by the inner transaction in
the absence of the outer transaction. No other results are possible.



How can you account for those consequences? (After protocol 13)
The transaction result for a fee-bump transaction contains an InnerTransactionResultPair which is binary compatible with TransactionResultPair. When searching for a specific transaction hash in a transaction result set, downstream systems should (1) check the hash in each transaction result pair (2) check the inner hash in each transaction result pair for which the result code is either txFEE_BUMP_INNER_SUCCESS or txFEE_BUMP_INNER_FAILED.

Does this mean that the transaction result for a fee-bump transaction contains the result for both the outer transaction and the inner transaction? (After protocol 13)
Yes! Every fee-bump transaction result contains a complete inner transaction result. This inner-transaction result is exactly what would have been produced had there been no fee-bump transaction, except that the inner fee will always be 0.

What does this result look like during validation? (After protocol 13)
If validation was successful, then the result is txFEE_BUMP_INNER_SUCCESS and the validation results from the validation of the inner transaction appear in the inner result. If validation was unsuccessful and the result is not txFEE_BUMP_INNER_FAILED, then the fee-bump transaction is invalid due to the outer transaction (eg. bad signatures on the outer transaction). If validation was unsuccessful and the result is txFEE_BUMP_INNER_FAILED, then the fee-bump transaction is invalid due to the inner transaction (eg. one of the operations is invalid, bad signatures on the inner transaction).
What does this hybrid result look like during application? (After protocol 13)
If application was successful, then the result is txFEE_BUMP_INNER_SUCCESS and the results from the application of the inner transaction appear in the inner result. If application was unsuccessful, then the result is txFEE_BUMP_INNER_FAILED and the results from the application of the inner transaction appear in the inner result. Application never fails due to the outer transaction.

How does “application” never fail due to the outer FeeBump transaction? What about replay prevention? (After protocol 13)
The only purpose of an outer transaction is to get an inner transaction included in a transaction set. Since the outer FeeBump transaction has no side-effects other than paying fee, and at the time the fee is paid the outer transaction must have been valid (otherwise nodes would not have voted for it), there is no reason to check validity at apply time. Therefore, the sequence number of the inner transaction is always consumed at apply time. Inner transactions still have their validity checked at apply time even after protocol 13.








## Fee-Bump Transaction Lifecycle

1. **Creation (Transaction Creator)**: A user creates a fee-bump transaction by taking an existing transaction envelope and specifying a fee account and maxium fee amount.  For more on regular transaction creation, see [Transactions](/transactions.mdx)  
   
2. **Signing (Transaction Signers)**: Once the fee-bump transaction is completely filled out, it is formed into a transaction envelope, which contains the fee-bump transaction along with the signature of the fee account.

3. **Submitting (Transaction Submitter)**: After signing, the fee-bump transaction is
   submitted to the Stellar network. If the fee-bump transaction is invalid, it will be immediately
   rejected by Stellar Core based on [the validity rules of a
   fee-bump transaction](#validity-of-a-fee-bump-transaction).  No fee will be consumed from the fee account.  
   
   Multiple transactions for the same account
   can be submitted, provided each of their sequence numbers are off by one. If they are all valid,
   Stellar Core will craft a transaction set with each of those transactions applied in sequence
   number order. Transactions are typically submitted using [Horizon](../.././api/introduction/index.mdx), but you
   can also submit the transaction directly to an instance of
   [Stellar Core](..//run-core-node/index.mdx).

4. **Propagating (Validator)**: Once Stellar Core has determined that a fee-bump transaction is valid, it
   will then propagate the transaction to all of the other servers to which it's connected. In this
   way, a valid transaction is flooded to the entire Stellar network.

5. **Crafting a candidate transaction set (Validator)**: When it's time to close the ledger, each
   Stellar Core validator (a Stellar Core node participating in consensus) takes
   all valid transactions it is aware of since the last ledger close and collects them into a
   candidate transaction set. If it hears about any incoming transactions now, it puts them aside
   for the next ledger close. If the number of operations in the candidate transaction set is
   greater than the maximum number of operations per ledger, transactions will be prioritized by
   their fee for inclusion in the set.  See the [Fees](./fees.mdx) doc for more info.

6. **Nominating a transaction set (Validator)**: Once each validator has crafted a candidate
   transaction set, the set is nominated to the network.

7. **Stellar Consensus Protocol (SCP) determines the final transaction set (Validator Network)**:
   [SCP](./scp.mdx) resolves any differences between candidate transaction sets, and ultimately determines a
   single transaction set to apply, the close time of the ledger, and any upgrades to the protocol
   that need to be applied network wide at apply time.
   * If a transaction doesn't make it into the transaction set, it is kept around in memory in
     order to be added to the next transaction set on a best effort basis.
   * If a transaction is kept in memory after a certain number of ledger closes, it will be banned
     for several additional ledgers. This means no attempt will be made to include it in a
     candidate transaction set additional ledgers during this time.

8. **Transaction apply order is determined (Validator Network)**: Once SCP agrees on a particular
   transaction set, the apply order is computed for the transaction set. This both shuffles the
   order of the set to create uncertainty for competing transactions and maintains the
   order of sequence numbers for multiple transactions per account.

9. **Fees are collected (Validator)**: [Fees](./fees.mdx) are collected for all transactions
   simultaneously.

10. **Application (Validator)**: Each transaction is applied in the order previously determined.
    For each transaction, the account's sequence number is consumed (increased by 1), the
    transaction's validity is checked again, and each operation is applied in the order they occur
    in the transaction. Operations may fail at this stage due to errors that can occur outside of
    the transaction and operation validity checks. For example, an insufficient balance for a
    payment is not checked at submission, and would fail at this time. If any operation fails, the
    entire transaction will fail, and all previous operations will be rolled back.

11. **Protocol Upgrades (Validator)**: Finally, upgrades are run if an upgrade took place. This
    can include arbitrary logic to upgrade the ledger state for protocol upgrades, along with
    ledger header modifications including the protocol version, base fee, maximum number of
    operations per ledger, etc. Once this has completed, the life cycle begins anew.

## Result Codes

Transaction return a result code listed in a table below. Error reference for operations can be
found in [List of Operations](../start/list-of-operationsx.mdx) doc.

| Result | Code | Description |
| --- | --- | --- |
| FEE_BUMP_INNNER_SUCCESS | 1 | The inner transaction contained in the fee bump succeeded. |
| SUCCESS | 0 | All operations contained in the transaction succeeded. |
| FAILED | -1 | One of the operations failed (check [List of operations](../start/list-of-operations.mdx) for errors). |
| TOO_EARLY | -2 | Ledger `closeTime` before `minTime` value in the transaction. |
| TOO_LATE | -3 | Ledger `closeTime` after `maxTime` value in the transaction. |
| MISSING_OPERATION | -4 | No operation was specified. |
| BAD_SEQ | -5 | Sequence number does not match source account. |
| BAD_AUTH | -6 | Too few valid signatures / wrong network. |
| INSUFFICIENT_BALANCE | -7 | Fee would bring account below [minimum reserve](./minimum-balance.mdx). |
| NO_ACCOUNT | -8 | Source account not found. |
| INSUFFICIENT_FEE | -9 | [Fee](./fees.mdx) is too small. |
| BAD_AUTH_EXTRA | -10 | Unused signatures attached to transaction. |
| INTERNAL_ERROR | -11 | An unknown error occured. |
| NOT_SUPPORTED | -12 | The transaction type is not supported |
| FEE_BUMP_INNER_FAILED | -13 | The fee bump inner transaction failed.  See [Fee Bumps](./fee-bumps.mdx) for more info.|


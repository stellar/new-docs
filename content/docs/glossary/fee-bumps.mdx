---
title: Fee-Bump Transactions
order:
---
A fee-bump transaction enables any account to pay the fee for an existing [transaction](./transactions.mdx) without the need to re-sign the existing transaction or manage sequence numbers.  They're useful if you need to increase the fee on an pre-signed transaction, or if you want to build a service that covers user fees.  Unlike a regular transaction, which contains 1-100 [operations](./operations.mdx), a fee bump transaction contains a single [transaction enevelope](./transactions.mdx/#transaction-envelopes).     

## Fee-Bump Transaction Attributes

### Existing Transaction Envelope
Each fee-bump transaction encloses a single transaction envelope, which itself encloses a single inner transaction.  Before creating a fee bump transaction, in other words, you must first have a [transaction](./transactions.mdx) wrapped with requisite signatures in a [transaction envelope](./transactions.mdx/#transaction-envelopes). 

In addition to a transaction envelope, each fee-bump transaction has the following attributes:

### Fee Account
The account that provides the fee for the fee-bump transaction.  It incurs the fee instead of the source account specified in the inner transaction.  The sequence number for the fee-bump transaction, however, is still taken from the source account specified in the inner transaction.

### Fee
The maximum per-operation fee you are willing to pay for the fee-bump transaction.  

A fee-bump transaction has an effective number of operations equal to one plus the number of operations in the inner transaction. Therefore, the minimum fee for a fee-bump transaction is one base fee *more* than the minimum fee for
the inner transaction, and the fee rate is normalized by one plus the number of operations in the inner transaction.  For more info on fee rate calculation, see [Fees](./fees.mdx).

#### Replace-by-Fee
You can use a fee bump transaction to increase the fee on a transaction originating from your own account — something you may want to consider if a transaction is failing to make the ledger due to surge pricing.  However, there is a condition: if you submit two distinct transactions with the same source account and sequence number, and the second transaction is a fee-bump transaction, the second transaction will be included in the transaction queue in place of the first transaction if and only if the fee bid of the second transaction is *at least 10x the fee bid of the first transaction*.  Though that limit may seem somewhat arbitrary, it was a deliberate design decision to limit DOS attacks without introducing too much complexity to the protocol.

## Fee-Bump Transaction Envelopes
Once a fee-bump transaction is ready to be signed, it's wrapped in a transaction envelope, which contains the fee-bump transaction as well as the signature of the fee account specified in the fee-bump transaction. 

Ultimately, transaction envelopes are passed around the network and are included in transaction sets, as opposed to raw transaction objects.    

## Validity of a Fee-Bump Transaction
A fee-bump transaction goes through a series of checks in its lifecycle to determine validity. For a fee-bump transaction to be valid, the following conditions must be met:   

- **Fee Account** — The fee account for the fee-bump transaction must exist on the ledger.

- **Fee** — The fee must be greater than or equal to the [network minimum fee](./fees.mdx) for the number of operations in the inner transaction, +1 for the fee bump.  It must also be greater than or equal to the fee specfied in the inner transaction.  Additionally, if the fee-bump transaction is taking advantage of the [replace-by-fee](#replace-by-fee) feature, in which a transaction envelope or fee-bump transaction envelope in the transaction queue is replaced by a fee-bump transaction envelope with the same sequence number and source account, the fee must be at least 10x higher. 

- **Fee Account Signature** — The fee-bump transaction envelope must contain a valid signaure for the fee account.  Additionally, the weight of that signature must meet the low threshold for the fee account, and the appropriate network passphrase must be part of the transaction hash signed by the fee account. See [Network Passphrases](./network-passphrase.mdx) for more. 

- **Fee Account Balance** — The fee account must have a sufficient XLM balance to cover the fee.

- **Inner Transaction** — For a fee-bump to succeed, the inner transaction must be valid, which means that it must meet the requirements described in the [Validity of a Transaction](./transactions.mdx/#validity-of-a-transaction) section. If validation of the inner transaction is successful, then the result is `FEE_BUMP_INNER_SUCCESS`, and the validation results from the validation of the inner transaction appear in the inner result.  If the inner transaction is invalid, the result is `FEE_BUMP_INNER_FAILED`, and the fee-bump transaction is invalid because the inner transaction is invalid.  

## Application
The sole purpose of a fee-bump transaction is to get an inner transaction included in a transaction set. Since the fee-bump transaction has no side-effects other than paying a fee — and at the time the fee is paid the outer transaction must have been valid (otherwise nodes would not have voted for it) — there is no reason to check the validity of the fee-bump transaction at apply time. Therefore, the sequence number of the inner transaction is always consumed at apply time. The inner transaction, however, will still have its validity checked at apply time.

Every fee-bump transaction result contains a complete inner transaction result. This inner-transaction result is exactly what would have been produced had there been no fee-bump transaction, except that the inner fee will always be 0.
 

## Fee-Bump Transaction Lifecycle

1. **Creation (Transaction Creator)**: A user creates a fee-bump transaction by taking an existing transaction envelope and specifying a fee account and maximum fee amount.  For more on regular transaction creation, see [Transactions](/transactions.mdx)  
   
2. **Signing (Transaction Signers)**: Once the fee-bump transaction is completely filled out, it is formed into a fee-bump transaction envelope, which contains the fee-bump transaction along with the signature of the fee account.

3. **Submitting (Transaction Submitter)**: After signing, the fee-bump transaction is
   submitted to the Stellar network. If the fee-bump transaction is invalid, it will be immediately
   rejected by Stellar Core based on [the validity rules of a
   fee-bump transaction](#validity-of-a-fee-bump-transaction).  No fee will be consumed from the fee account.  
   
   Multiple transactions for the same account
   can be submitted, provided each of their sequence numbers are off by one. If they are all valid,
   Stellar Core will craft a transaction set with each of those transactions applied in sequence
   number order. Transactions are typically submitted using [Horizon](../.././api/introduction/index.mdx), but you
   can also submit the transaction directly to an instance of
   [Stellar Core](..//run-core-node/index.mdx).

4. **Propagating (Validator)**: Once Stellar Core has determined that a fee-bump transaction is valid, it
   will then propagate the transaction to all of the other servers to which it's connected. In this
   way, a valid transaction is flooded to the entire Stellar network.

5. **Crafting a candidate transaction set (Validator)**: When it's time to close the ledger, each
   Stellar Core validator (a Stellar Core node participating in consensus) takes
   all valid transactions it is aware of since the last ledger close and collects them into a
   candidate transaction set. If it hears about any incoming transactions now, it puts them aside
   for the next ledger close. If the number of operations in the candidate transaction set is
   greater than the maximum number of operations per ledger, transactions will be prioritized by
   their fee for inclusion in the set.  See the [Fees](./fees.mdx) doc for more info.

6. **Nominating a transaction set (Validator)**: Once each validator has crafted a candidate
   transaction set, the set is nominated to the network.

7. **Stellar Consensus Protocol (SCP) determines the final transaction set (Validator Network)**:
   [SCP](./scp.mdx) resolves any differences between candidate transaction sets, and ultimately determines a
   single transaction set to apply, the close time of the ledger, and any upgrades to the protocol
   that need to be applied network wide at apply time.
   * If a transaction doesn't make it into the transaction set, it is kept around in memory in
     order to be added to the next transaction set on a best effort basis.
   * If a transaction is kept in memory after a certain number of ledger closes, it will be banned
     for several additional ledgers. This means no attempt will be made to include it in a
     candidate transaction set additional ledgers during this time.

8. **Transaction apply order is determined (Validator Network)**: Once SCP agrees on a particular
   transaction set, the apply order is computed for the transaction set. This both shuffles the
   order of the set to create uncertainty for competing transactions and maintains the
   order of sequence numbers for multiple transactions per account.

9. **Fees are collected (Validator)**: [Fees](./fees.mdx) are collected for all transactions
   simultaneously.

10. **Application (Validator)**: Each transaction is applied in the order previously determined.
    For each transaction, the account's sequence number is consumed (increased by 1), the
    transaction's validity is checked again, and each operation is applied in the order they occur
    in the transaction. Operations may fail at this stage due to errors that can occur outside of
    the transaction and operation validity checks. For example, an insufficient balance for a
    payment is not checked at submission, and would fail at this time. If any operation fails, the
    entire transaction will fail, and all previous operations will be rolled back.

11. **Protocol Upgrades (Validator)**: Finally, upgrades are run if an upgrade took place. This
    can include arbitrary logic to upgrade the ledger state for protocol upgrades, along with
    ledger header modifications including the protocol version, base fee, maximum number of
    operations per ledger, etc. Once this has completed, the life cycle begins anew.

## Result Codes

Transaction return a result code listed in a table below. Error reference for operations can be
found in [List of Operations](../start/list-of-operationsx.mdx) doc.

| Result | Code | Description |
| --- | --- | --- |
| FEE_BUMP_INNNER_SUCCESS | 1 | The inner transaction contained in the fee bump succeeded. |
| SUCCESS | 0 | All operations contained in the transaction succeeded. |
| FAILED | -1 | One of the operations failed (check [List of operations](../start/list-of-operations.mdx) for errors). |
| TOO_EARLY | -2 | Ledger `closeTime` before `minTime` value in the transaction. |
| TOO_LATE | -3 | Ledger `closeTime` after `maxTime` value in the transaction. |
| MISSING_OPERATION | -4 | No operation was specified. |
| BAD_SEQ | -5 | Sequence number does not match source account. |
| BAD_AUTH | -6 | Too few valid signatures / wrong network. |
| INSUFFICIENT_BALANCE | -7 | Fee would bring account below [minimum reserve](./minimum-balance.mdx). |
| NO_ACCOUNT | -8 | Source account not found. |
| INSUFFICIENT_FEE | -9 | [Fee](./fees.mdx) is too small. |
| BAD_AUTH_EXTRA | -10 | Unused signatures attached to transaction. |
| INTERNAL_ERROR | -11 | An unknown error occured. |
| NOT_SUPPORTED | -12 | The transaction type is not supported |
| FEE_BUMP_INNER_FAILED | -13 | The fee bump inner transaction failed.  See [Fee Bumps](./fee-bumps.mdx) for more info.|


---
title: Fee Bumps
order:
---
Fee Bump transactions enable any account to pay the fee for an existing transaction without the need to re-sign the existing transaction or manage sequence numbers.  If a transaction has insufficient fee, for example due to either surge pricing or an increase in the baseFee, that transaction will not be included in a transaction set. If the transaction is only signed by the party that wants to execute it then it is possible to simply craft a new transaction with higher fee, sign it, and submit it. But there are many circumstances where this is not possible, such as when pre-signed and pre-authorized transactions are involved.  

Unlike regular transactions, which contain operations, a fee-bump transaction contains a transaction envelope.  

To bump a fee, you create a fee-bump transaction which contains the transaction envelope that you want to submit, specifying the fee that you want to pay and the account that will pay it. If you control that account, then you can sign the fee-bump transaction and form a fee-bump transaction envelope from the fee-bump transaction and your signature. Now this can be submitted successfully if the new fee is sufficiently high.  

The fee and an account that will pay that fee override what was specified in the contained transaction. 

## Fee Bump Transaction Attributes

Each fee bump transaction has the following attributes:

### Source Account

The account that account that provides the fee and sequence number for the fee bump transaction.

### Fee

Each fee bump transaction incurs a fee, which is paid by the source account.  A fee-bump transaction has an effective number of operations equal to one plus the number of operations in the inner transaction. Correspondingly, the minimum
fee for the fee-bump transaction is one base fee more than the minimum fee for
the inner transaction. Similarly, the fee rate (see CAP-0005) is normalized by one plus the number of operations in the inner transaction rather than the number of operations in the inner transaction alone.

#### Replace-by-Fee
If you're submitting 

If a node receives a valid `TransactionEnvelope E'` of type
`ENVELOPE_TYPE_TX_FEE_BUMP` with source account `A` and sequence number `N` when
it already has a `TransactionEnvelope E` with source account `A` and sequence
number `N` in the transaction queue, then it should replace `E` with `E'` if and
only if the fee rate for `E'` is at least 10 times the fee rate for `E`. It
should be emphasized that source account in this section refers specifically to
the source account of the _sequence number_ of the transaction, although these
transactions may still have different fee source accounts.

What happens if I submit two distinct transactions with the same source account and sequence number? (After protocol 13)
If the second transaction is not a fee-bump transaction, then this behavior is unchanged from before protocol 13. Assuming both transactions were submitted to the same instance of stellar-core in a small time window and at least one of them is a fee-bump transaction, the second transaction may or may not be rejected as invalid depending on the fee bid as a consequence of replace-by-fee semantics. If the fee bid of the second transaction is at least 10-times the fee bid of the first transaction, then the second transaction will be included in the transaction queue in place of the first transaction. The intention is to extend replace-by-fee semantics to all transactions in a future release of stellar-core, but this is not a protocol change.

#### Surge Pricing
The logic for surge pricing is unchanged. 

### Sequence Number

Each transaction has a sequence number associated with the source account. Transactions follow a strict ordering rule when it comes to processing transactions per account in order to prevent double-spending. When submitting a single transaction, you should submit a sequence number 1 greater than the current sequence number. For example, if the sequence number on the account is 4, then the incoming transaction should have a sequence number of 5.

However, if several transactions with the same source account make it into the same transaction set, they are ordered and applied according to sequence number. For example, if you submitted 3 transactions that shared the same source account and the account is currently at sequence number 5, the transactions must have sequence numbers 6, 7, and 8.


### List of Signatures

Up to 20 signatures can be attached to a transaction. See [Multi-sig](./multisig.mdx) for more information. A transaction is considered invalid if it includes signatures that aren't needed to authorize the transaction — superfluous signatures aren't allowed.

Signatures are required to authorize operations and to authorize changes to the source account (fee and sequence number).

Come from the inner transaction:
* List of operations
* List of signatures
* Memo
* Timebounds

## Fee Bump Transaction Envelopes

Before I can explain what a fee-bump transaction is, let's quickly review some Stellar terminology. An operation is the smallest unit of work in the Stellar protocol. Sending a payment or managing an offer are examples of operations. A transaction contains up to 100 operations which are applied atomically, along with other information such as the fee and the sequence number. Although we often talk about submitting a transaction to the Stellar network, this is a subtle abuse of language. In reality, transactions do not carry signatures so they cannot be submitted to the network. Transaction envelopes, which wrap a transaction and the corresponding signatures, are what clients actually submit to the network.

Once a transaction is ready to be signed, the transaction object is wrapped in an object called a `Transaction Envelope`, which contains the transaction as well as a set of signatures. Most transaction envelopes only contain a single signature along with the transaction, but in [multi-signature setups](./multisig.mdx) it can contain many signatures.

Ultimately, transaction envelopes are passed around the network and are included in transaction sets, as opposed to raw Transaction objects.

It's of note that each signer signs the hash of the transaction object in addition to the network passphrase. This is done to ensure that a given transaction can only be submitted to the intended network by its signers. For more information, see [Network Passphrases](./network-passphrase.mdx).

#### Application and Results
Even if the outer transaction of a fee-bump is invalid during application, we
will still apply the inner transaction. Specifically, the behavior is:

- Remove used one-time signers for the outer transaction
- Apply the inner transaction (as if there were no outer transaction)

If the inner transaction succeeds, then the result is `txFEE_BUMP_INNER_SUCCESS`
and the `innerResultPair` is what would have been produced by the inner
transaction in the absence of the outer transaction. Analogously, if the inner
transaction fails, then the result is `txFEE_BUMP_INNER_FAILED` and the
`innerResultPair` is what would have been produced by the inner transaction in
the absence of the outer transaction. No other results are possible.



How can you account for those consequences? (After protocol 13)
The transaction result for a fee-bump transaction contains an InnerTransactionResultPair which is binary compatible with TransactionResultPair. When searching for a specific transaction hash in a transaction result set, downstream systems should (1) check the hash in each transaction result pair (2) check the inner hash in each transaction result pair for which the result code is either txFEE_BUMP_INNER_SUCCESS or txFEE_BUMP_INNER_FAILED.

Does this mean that the transaction result for a fee-bump transaction contains the result for both the outer transaction and the inner transaction? (After protocol 13)
Yes! Every fee-bump transaction result contains a complete inner transaction result. This inner-transaction result is exactly what would have been produced had there been no fee-bump transaction, except that the inner fee will always be 0.

What does this result look like during validation? (After protocol 13)
If validation was successful, then the result is txFEE_BUMP_INNER_SUCCESS and the validation results from the validation of the inner transaction appear in the inner result. If validation was unsuccessful and the result is not txFEE_BUMP_INNER_FAILED, then the fee-bump transaction is invalid due to the outer transaction (eg. bad signatures on the outer transaction). If validation was unsuccessful and the result is txFEE_BUMP_INNER_FAILED, then the fee-bump transaction is invalid due to the inner transaction (eg. one of the operations is invalid, bad signatures on the inner transaction).
What does this hybrid result look like during application? (After protocol 13)
If application was successful, then the result is txFEE_BUMP_INNER_SUCCESS and the results from the application of the inner transaction appear in the inner result. If application was unsuccessful, then the result is txFEE_BUMP_INNER_FAILED and the results from the application of the inner transaction appear in the inner result. Application never fails due to the outer transaction.

How does “application” never fail due to the outer FeeBump transaction? What about replay prevention? (After protocol 13)
The only purpose of an outer transaction is to get an inner transaction included in a transaction set. Since the outer FeeBump transaction has no side-effects other than paying fee, and at the time the fee is paid the outer transaction must have been valid (otherwise nodes would not have voted for it), there is no reason to check validity at apply time. Therefore, the sequence number of the inner transaction is always consumed at apply time. Inner transactions still have their validity checked at apply time even after protocol 13.





## Validity of a Fee Bump Transaction

Submitted fee-bump transaction envelopes go through a similar validation process. But unlike transaction envelopes, fee-bump transaction envelopes support the replace-by-fee mechanism. When replace-by-fee occurs, a transaction envelope or fee-bump transaction envelope in the transaction queue is replaced by a fee-bump transaction envelope with the same sequence number and source account, but a fee that is at least 10x higher. Imagine, for example, that you submit a transaction envelope to a Stellar-Core node which is accepted because its fee was above the minimum fee. But your transaction envelope does not get included in the ledger due to surge pricing, and you want to accelerate the process. Without the replace-by-fee mechanism, you would not be able to successfully submit a fee-bump transaction envelope with a higher fee because the sequence number would not be sequential. With it, however, you are actually able to to bump the fee.
The following conditions determine whether a fee bump transaction is valid:

- **Source Account** — The source account for the fee bump must exist on the ledger.

`E.feeBump().tx.feeSource` has sufficient available native balance (see
  CAP-0003) to pay `E.feeBump().tx.fee` in addition to fees that will be paid by
  this account for other transactions, otherwise return `txINSUFFICIENT_BALANCE`  


- **Fee** — The fee must be greater than or equal to the [network minimum fee](./fees.mdx) for the number of operations in the inner transaction, +1 for the fee bump.  It must also be greater than or equal to the fee specfied in the inner transaction. - 

- **Sequence Number** — For the transaction to be valid, the sequence number must be 1 greater than the sequence number stored in the fee bump source account [account entry](./accounts.mdx) _when the transaction is applied_. This means when checking the validity of multiple transactions with the same source account in a candidate transaction set, they must all be valid transactions and their sequence numbers must be offset by 1 from each other. When it comes to apply time, they are ordered and applied according to their sequence number.

- **List of Signatures** — In addition to meeting the signature requirements of each operation in the transaction, the following requirements must be met for the transaction:
  - The appropriate network passphrase was part of the transaction hash that was signed by each of the signers. See [Network Passphrases](./network-passphrase.mdx) for more.
  - The combined weight of all signatures for the source account _of the fee bump transaction_ meets the low threshold for the source account. This is necessary in order for fees to be taken and the sequence number to be incremented later in the transaction lifecycle.



## Fee Bump Transaction Lifecycle

1. **Creation (Transaction Creator)**: A user creates a transaction by setting the source
   account, sequence number, list of operations and their respective parameters, fee, and
   optionally a memo and timebounds.  You can try this out [using the Stellar
   Laboratory](https://laboratory.stellar.org/#txbuilder?network=test).

2. **Signing (Transaction Signers)**: Once the transaction is completely filled out, the
   transaction is formed into a transaction envelope, which contains the transaction itself and a
   list of signers. All the required signatures must be collected and added to the transaction
   envelope's list of signers.  Commonly it's just the signature of the account doing the
   transaction, but more complicated setups can require collecting [signatures from multiple
   parties](./multisig.mdx).

3. **Submitting (Transaction Submitter)**: After signing, the transaction must be valid and can now
   be submitted to the Stellar network. If the transaction is invalid, it will be immediately
   rejected by stellar-core based on [the validity rules of a
   transaction](#validity-of-a-transaction), the account's sequence number will not be incremented,
   and no fee will be consumed from the source account.  Multiple transactions for the same account
   can be submitted, provided each of their sequence numbers are off by one. If they are all valid,
   Stellar Core will craft a transaction set with each of those transactions applied in sequence
   number order. Transactions are typically submitted using [Horizon](../.././api/introduction/index.mdx), but you
   can also submit the transaction directly to an instance of
   [Stellar Core](..//run-core-node/index.mdx).

4. **Propagating (Validator)**: Once Stellar Core has determined that a transaction is valid, it
   will then propagate the transaction to all of the other servers to which it's connected. In this
   way, a valid transaction is flooded to the entire Stellar network.

5. **Crafting a candidate transaction set (Validator)**: When it's time to close the ledger, each
   Stellar Core validator (a Stellar Core node participating in consensus) takes
   all valid transactions it is aware of since the last ledger close and collects them into a
   candidate transaction set. If it hears about any incoming transactions now, it puts them aside
   for the next ledger close. If the number of operations in the candidate transaction set is
   greater than the maximum number of operations per ledger, transactions will be prioritized by
   their fee for inclusion in the set.  See the [Fees](./fees.mdx) doc for more info.

6. **Nominating a transaction set (Validator)**: Once each validator has crafted a candidate
   transaction set, the set is nominated to the network.

7. **Stellar Consensus Protocol (SCP) determines the final transaction set (Validator Network)**:
   [SCP](./scp.mdx) resolves any differences between candidate transaction sets, and ultimately determines a
   single transaction set to apply, the close time of the ledger, and any upgrades to the protocol
   that need to be applied network wide at apply time.
   * If a transaction doesn't make it into the transaction set, it is kept around in memory in
     order to be added to the next transaction set on a best effort basis.
   * If a transaction is kept in memory after a certain number of ledger closes, it will be banned
     for several additional ledgers. This means no attempt will be made to include it in a
     candidate transaction set additional ledgers during this time.

8. **Transaction apply order is determined (Validator Network)**: Once SCP agrees on a particular
   transaction set, the apply order is computed for the transaction set. This both shuffles the
   order of the set to create uncertainty for competing transactions and maintains the
   order of sequence numbers for multiple transactions per account.

9. **Fees are collected (Validator)**: [Fees](./fees.mdx) are collected for all transactions
   simultaneously.

10. **Application (Validator)**: Each transaction is applied in the order previously determined.
    For each transaction, the account's sequence number is consumed (increased by 1), the
    transaction's validity is checked again, and each operation is applied in the order they occur
    in the transaction. Operations may fail at this stage due to errors that can occur outside of
    the transaction and operation validity checks. For example, an insufficient balance for a
    payment is not checked at submission, and would fail at this time. If any operation fails, the
    entire transaction will fail, and all previous operations will be rolled back.

11. **Protocol Upgrades (Validator)**: Finally, upgrades are run if an upgrade took place. This
    can include arbitrary logic to upgrade the ledger state for protocol upgrades, along with
    ledger header modifications including the protocol version, base fee, maximum number of
    operations per ledger, etc. Once this has completed, the life cycle begins anew.

## Possible Errors

Transaction can fail with one of the errors in a table below. Error reference for operations can be
found in [List of Operations](../start/list-of-operationsx.mdx) doc.

| Error | Code | Description |
| --- | --- | --- |
| FAILED | -1 | One of the operations failed (check [List of operations](../start/list-of-operations.mdx) for errors). |
| TOO_EARLY | -2 | Ledger `closeTime` before `minTime` value in the transaction. |
| TOO_LATE | -3 | Ledger `closeTime` after `maxTime` value in the transaction. |
| MISSING_OPERATION | -4 | No operation was specified. |
| BAD_SEQ | -5 | Sequence number does not match source account. |
| BAD_AUTH | -6 | Too few valid signatures / wrong network. |
| INSUFFICIENT_BALANCE | -7 | Fee would bring account below [minimum reserve](./minimum-balance.mdx). |
| NO_ACCOUNT | -8 | Source account not found. |
| INSUFFICIENT_FEE | -9 | [Fee](./fees.mdx) is too small. |
| BAD_AUTH_EXTRA | -10 | Unused signatures attached to transaction. |
| INTERNAL_ERROR | -11 | An unknown error occured. |


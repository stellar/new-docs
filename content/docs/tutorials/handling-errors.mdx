---
title: Handling Errors Gracefully
order: 100
---

import { CodeExample } from "components/CodeExample";

When working with a payment network like Stellar[,](https://www.youtube.com/watch/TLXo9IFVboY) expecting the unexpected is critical in ensuring a good user experience: one in which money doesn't get lost, actions happen when they're supposed to (or as early as they can), and everyone's view of the network is as accurate as possible.

In many of the tutorials and code samples throughout this documentation, we've minimized the error handling code to reduce verbosity and focus on the essence of the examples. Here, we'll do the exact opposite, because error handling *is* the essence: by the end, you should be able to categorize errors and understand the best, most-idiomatic way to handle them in your application.

Since [the SDKs](../software-and-sdks/) are the main way people interact with the Stellar network, their error reporting will be the main focus of this document. At the end of the day, though, they're just human- and API-friendly abstractions on the underlying problems. As such, the knowledge should be relatively easy to transfer to other scenarios such as using a 3rd party SDK or interfacing with Horizon directly over HTTP.


## Types of Errors
To start, let's categorize the possible error scenarios. There are three main classes worth considering:

  - **query-related HTTP errors** that occur when performing `GET` requests to Horizon via various API endpoints (querying balances, the order book, etc.), whose full enumeration is listed on the [Errors](../../api/errors/http-status-codes/) page;

  - **transaction submission-related HTTP errors** that occur when performing a `POST` request to Horizon via the `/transaction` endpoint (e.g. via `sdk.submitTransaction` in the JavaScript SDK), whose full enumeration is similarly listed on the [Errors](../../api/errors/result-codes/) page; and 

  - **transient failures** such as the Horizon instance you're relying on going down, your router resetting, AWS hiccupping, etc. which may occur rarely but are nonetheless crucial to handle.

There isn't a universal way to handle HTTP errors: some are the result of user error, some are dynamically recoverable, and some are unavoidable altogether. Transient errors are even trickier to handle due to their rarity and uncertainty, but can be made easier under the assumption that the failing backends will be up to speed again soon. 

Let's dive into each of these separately: we'll go over examples, some common causes, and recommended resolution strategies.


## Transaction Submission Errors
Just like with query errors, there are dozens of possible causes of a transaction submission failure and they all return their own internal result codes. Horizon attempts to wrangle the asynchronous nature of the beast that is Stellar Core into a synchronous flow more familiar to application developers. This requires making assumptions and imposing restrictions, and though it's a simpler model there are still caveats to be aware of. 

Here are some of the common errors encountered when performing a `POST /transactions`:

  - [400 error, `tx_bad_seq`](#invalid-sequences)
  - [504 error, timeout](#timeouts)
  - [Surge pricing, `tx_insufficient_fee`](#surge-pricing)
  - [No HTTP response](#outages)

Keep in mind this general rule of thumb: **any response other than `200 OK` or `400 Bad Request` means that the final status of the transaction is unknown.**

### 400 Errors
Generally-speaking, if you get a 400 error during transaction submission, there are two main causes: either your transaction is in an unacceptable format or Stellar Core rejected your transaction. The former case is described by the [`transaction_malformed`](https://developers.stellar.org/api/errors/http-status-codes/horizon-specific/transaction-malformed/) error code and the latter by the [`transaction_failed`](https://developers.stellar.org/api/errors/http-status-codes/horizon-specific/transaction-failed/) code.

Some transaction failures are recoverable; you should look at the `extras.result_code` field in the response message to determine the [root cause](https://developers.stellar.org/api/errors/result-codes/transactions/). One of these recoverable errors is `tx_bad_seq`, where the sequence number on the transaction doesn't match what's expected for the account.


### Invalid Sequences
These errors typically occur when you have an outdated view of an account due to other transactions happening outside of your worldview. This could be because the account is used on multiple devices, you have concurrent submissions happening, or a number of other reasons.

Thankfully, the solution is relatively simple: retrieve the account details and try again with an updated sequence number.

<CodeExample>

```js
// suppose `account` is an outdated `AccountResponse` object
let tx = sdk.TransactionBuilder(account, ...)/* etc */.build()
server.submitTransaction(tx).catch(function (error)) {
  if (error.response && error.status == 400 && error.extras && 
      error.extras.result_codes.transaction == sdk.TX_BAD_SEQ) {
    return server.accounts()
      .accountId(account.accountId())
      .then(function (response) {
        let tx = sdk.TransactionBuilder(response, ...)/* etc */.build()
        return server.submitTransaction(tx);
      });
  }
  // ...other error conditions...
}
```

</CodeExample>

Despite the simple solution, something to be extremely careful about is **duplicate submissions**. Suppose you submitting transactions from multiple places in your application concurrently, and your user spammed the "Send Payment" button a few times in impatience. If you try to send the *exact same* payment transaction for each tap, naturally only one of them will succeed. However, since the others fail with `tx_bad_seq`, the above code will blindly resubmit them with an updated sequence number and **also succeed**, ultimately resulting in more than one payment being made when only one was intended. In summary, be careful with resubmissions and recoverable transaction errors.




### Timeouts
If you receive a 504 error from Horizon after a transaction submission, you've encountered a timeout. In the Stellar universe, a timeout indicates something a little nebulous and non-traditional: it's more of a *warning* that your request hasn't been fulfilled within a reasonable amount of time *yet* more than an error. This subtlety arises because of the nature of the relationship between Horizon and Stellar Core: the network might take some time to accept a transaction---especially one with a low fee, see [Surge Pricing](#surge-pricing) later---on the order of 5-10 minutes in the worst cases, whereas Horizon needs to provide developers with a response within 30 seconds or so.

This leads to a very important point: **receiving a 504 for your transaction submission does not mean the transaction did not make it to the network**.

There's no mechanism to "cancel" a transaction after it has been submitted aside from by exceeding its timebounds. In fact, one of the best tools available for managing transaction failures is through [timebounds](https://developers.stellar.org/docs/glossary/transactions/#time-bounds). While optional, they're *crucial* in simplifying error handling: it's much easier to know when to check a transaction's status when you know the maximum amount of time it can be stuck.

With this trick in our back pocket, resolving 504s is straightforward: until the timebound has expired, you can safely retry submission *without modifying the transaction*. Horizon makes an important guarantee (excerpt is from [this example](https://developers.stellar.org/docs/tutorials/send-and-receive-payments/#send-a-payment)) for this scenario:

> If the transaction has already been successfully applied to the ledger, Horizon will simply return the saved result and not attempt to submit the transaction again. Only in cases where a transactionâ€™s status is unknown (and thus will have a chance of being included into a ledger) will a resubmission to the network occur.

In other words, if your transaction made it through after the 504, you'll get your previously-submitted transaction back. If it didn't (e.g. a `tx_too_late` result code), you're essentially back to square one: you might 504 again, fail for another reason (e.g. `tx_bad_seq`), or succeed.

#### Transaction Bans
Note the following caveat of the [transaction lifecycle](https://developers.stellar.org/docs/glossary/transactions/#transaction-lifecycle): 

> If a transaction is kept in memory after a certain number of ledger closes, **it will be banned for several additional ledgers.** This means no attempt will be made to include it in a candidate transaction set additional ledgers during this time.

If you trigger a ban scenario while your timebound is still in the future, you may have no choice but to use a [fee-bump transaction](#bumping-fees-on-past-transactions) to get into the ledger.

#### Surge Pricing
When the Stellar network undergoes bursts of activity, [surge pricing](https://developers.stellar.org/docs/glossary/fees/#surge-pricing) might kick in. This and other fee fluctuations can cause unexpected errors during transaction submission in applications that don't plan ahead for its dynamic nature.

There are two main approaches for dealing with this variance:

  1. **Track fee fluctuations** via the [`fee_stats` endpoint](https://developers.stellar.org/api/aggregations/fee-stats/). This can let you make informed, specific choices about the fee you're comfortable paying. Alternatively, simply...

  2. **Set the highest fee** you are comfortable with. Crucially, you should remember that *this doesn't mean you'll **pay** that on every transaction*. You will only pay whatever is necessary to get you into the ledger: under normal (non-surge) circumstances, even with a higher *maximum* fee set, you will pay the *standard* fee (100 stroops as of this writing).

The latter strategy balances simplicity, efficacy, and convenience, but unless you set your maximum high enough simply *never* be exceeded, can still lead to failures. The former strategy can provide more-reliable submissions by allowing tighter guarantees about whether or not a transaction will be accepted. In general, though, it's important to track fee costs: if the network saturates beyond your maximum willingness to pay, perhaps waiting for activity to die down or periodically retrying with the same fee is the best approach for your use case.

If you want to match a fee error **exactly**, you might write something like this:

<CodeExample>

```js
function isFeeError(error) {
  return
    error.response !== undefined && 
    error.status == 400 &&
    error.extras &&
    error.extras.result_codes.transaction == sdk.TX_INSUFFICIENT_FEE;
}
```

</CodeExample>

Of course, there are much more streamlined ways to *combine* errors together, but this will be used below to demonstrate the (very) specific check.

##### Example: Paying 10% above average
Suppose we want a fairly conservative fee-paying strategy: we're only willing to pay a 10% higher fee than the average transaction paid.

<CodeExample>

```js
// when submitting any transaction, first query fee stats
server.feeStats().then(function (response) {
  let avgFee = parseFloat(response.fee_charged.p50);
  let tx = base.TransactionBuilder(someAccount, {
    fee: (avgFee * 1.10).toFixed(0),  // bump & convert to int
    networkPassphrase: // ...
  });
  // ...build the rest of the tx... 
  tx.sign(someAccount);
  return server.submitTransaction(tx);
});
```

</CodeExample>

##### Bumping fees on past transactions
It's possible that even with the liberal fee-paying policy, your transaction fails to make it into the ledger due to insufficient funds or untimely surges. Resolving this problem is exactly the goal of a [fee-bump transaction](https://developers.stellar.org/docs/glossary/fee-bumps/); the following snippet shows how you can resubmit a transaction with a higher fee given that you have the original [transaction envelope](https://developers.stellar.org/docs/glossary/transactions/#transaction-envelopes):

<CodeExample>

```js
// Let `lastTx` be some transaction that fails submission due to high fees, and
// `lastFee` be the maximum fee (expressed as an int) willing to be paid by 
// `account` for `lastTx`.
server.submitTransaction(lastTx).catch(function (error) {
  if (isFeeError(error)) {
    let bump = sdk.TransactionBuilder.buildFeeBumpTransaction(
      account,      // account that will PAY the new fee
      lastFee * 10, // new fee
      lastTx,
      server.networkPassphrase
    );
    bump.sign(someAccount);
    return server.submitTransaction(bump);
  }
  // ...other error conditions...
}).then(...);
```

</CodeExample>

Note an [important stipulation](https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee) of fee bumping that's fulfilled above:

> If you submit two distinct transactions with the same source account and sequence number, and the second transaction is a fee-bump transaction, the second transaction will be included in the transaction queue in place of the first transaction if and only if **the fee bid of the second transaction is at least 10x the fee bid of the first transaction**.


### Outages
The simplest transient "outage" scenario could be a machine disconnecting from the Internet:

    curl: (6) Could not resolve host: horizon.stellar.org

but there are innumerable other scenarios (DNS down, firewall misconfigured, AWS outage, etc. just to name a few) that can cause them.

Receiving no response from Horizon after a submission is very similar to receiving a [504 timeout](#timeouts): you're uncertain about the outcome of the transaction submission.

It's obviously crucial to determine whether or not it went through or not, but you can likewise *just keep trying* submission until the timebounds expire. Once they have, though, if the transient error hasn't resolved itself, you should just stop and wait; submitting a new transaction might result in a undesirable duplicate action. 

<CodeExample>

```js
let server = sdk.Server("horizon.stellar.org");

function submitTransaction(tx) {
    // ... 
    return txSubWithBackoff(tx, 1);
}

function txSubWithBackoff(tx, timeout) {
  return server.submitTransaction(tx).catch(function (error) {
    // transient error or timeout? back-off then try again
    if (isTimeoutOrOutage(error)) {
      return sleep(timeout).then(function () {
        return txSubWithBackoff(tx, timeout + 5)
      });
    }
    // ...other error handling...
  }
}

function isTimeoutOrOutage(error) {
  return !error.response || error.status == 504;
}
```

</CodeExample>

Obviously, if the Horizon instance you're relying on itself is down, this only becomes viable when you eventually get results.


## Query Errors
There are many, *many* possible mistakes you can make while querying the Horizon API. Naturally, using an SDK will alleviate the silliest ones, but there are still plenty of ways to go wrong. There are two main error types encountered during a `GET` request: submit an **invalid query** (400 error) or request a **missing resource** (404 error). Both can be achieved on the same endpoint. The SDKs make a point to distinguish these errors (e.g. `NotFoundError` vs the generic `NetworkError` in the JavaScript SDK).

As an example, consider the [`/claimable_balances` endpoint](https://developers.stellar.org/api/resources/claimablebalances/). You'd get a 400 error when looking up a balance by an invalid ID:

<CodeExample>

```bash
curl https://horizon-testnet.stellar.org/claimable_balances/0000
```

</CodeExample>

<CodeExample>

```json
{
  "type": "https://stellar.org/horizon-errors/bad_request",
  "title": "Bad Request",
  "status": 400,
  "detail": "The request you sent was invalid in some way.",
  "extras": {
    "invalid_field": "id",
    "reason": "Invalid claimable balance ID"
  }
}
```

</CodeExample>

On the other hand, you'd get a 404 with a valid ID if it doesn't resolve to an actual claimable balance:

<CodeExample>

```bash
curl https://horizon-testnet.stellar.org/claimable_balances/000000000000000000000000000000000000000000000000000000000000000000000000
```

</CodeExample>

<CodeExample>

```json
{
  "type": "https://stellar.org/horizon-errors/not_found",
  "title": "Resource Missing",
  "status": 404,
  "detail": "The resource at the url requested was not found.  This usually occurs for one of two reasons:  The url requested is not valid, or no data in our database could be found with the parameters provided."
}
```

</CodeExample>

### Rate Limiting
If you're using the SDF's public Horizon instance, you may get a `429` error when exceeding the [rate limits](https://developers.stellar.org/api/introduction/rate-limiting/). If you're encountering this frequently, it may be time to [deploy your own](https://developers.stellar.org/docs/run-api-server/) Horizon instance!


## Footnotes

  1. Be sure to integrate backoff into your retry mechanism for handling [outages](#outages) and [timeouts](#timeouts). There are plenty of recommendations [out there](https://backoff-utils.readthedocs.io/en/latest/strategies.html#why-are-backoff-strategies-useful) for various backoff strategies you can employ. In our examples above, we'll implement a simple linear backoff.
